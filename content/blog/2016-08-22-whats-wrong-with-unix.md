---
comments: true
date: 2016-08-22T00:00:00Z
tags:
- Unix
title: What's wrong with Unix?
type: '/blog/post'
layout: 'single'
---
I’ve been learning more about Unix and systems, but some recent opinions I've read remind me that nothing is perfect. 

When I came across [this tweet from Steve Klabnik](https://twitter.com/steveklabnik/status/766683399062953985) which led me to [this tweet about a post by Max Kreminski re: Unix not being good](https://twitter.com/frankus/status/766680213686071296), it got me to reflect on some thoughts on why Unix might not be so great. 

I’m guessing that a lot of other people that learned to program later in life or through a bootcamp don’t have perhaps the same sort of nostalgia or even reverence for Unix as other programmers that came of age at a different time or taught themselves how to program via a Unix system. You just accept that this is the defacto system and move on.

But I've always found it amazing that we were still using a system from the 70s…was it really that good that everyone should be using it or a derivative of it? Is it appropriate for the computing that we do now or are we just locked into using something because we’ve invested so much? Early on, I think I even asked an instructor why a file-based system was the ‘best’ system for organizing data and why we were using terminal emulators that mimicked 70s terminals, (both mentioned by Kreminski).

It’s easy to start learning something and be delighted by the things you can now do; that mastery, I think, partially obfuscates the doubt there might be there about whether or not something is still relevant and appropriate to the task at hand.

My observation is that like a lot of other tools, using Unix derived systems like Linux or Mac OS/X  through the command line is not about using the appropriate tool for the work but the most common one, (and also as a rite of passage, hence Kreminski’s comment about ’normal users’ vs ’serious developers’). Many of the issues brought up by Kreminski (who also cites Dan Norman’s earlier criticisms) are valid. The complexity of Unix, (the flag system for the ls command is given as an example), is something that overwhelms novice programmers as well and why they tend to get frustrated and revert back to the GUI to accomplish tasks. It’s not that they’re not smart enough to learn how Unix works, (which I do hear from people…), it might be that Unix and its derivatives have a 'usability problem.''

**Historical Self-Awareness**

The history of computing is something that I’m very interested in. I found a cache of books from my father’s time as a computer science grad student from the 70s and early 80s, and started to read through some of them. This helped me better understand what problems and tools programmers and computer scientists were dealing with. I was better able to situate and frame some of the tools I was trying to master now within a historical context that made them less random and mysterious.

What worries me is that Kreminski describes what amounts to historical self-awareness as a ’superpower’, and I think that is telling about this industry. When I mentioned reading through these books, the most frequent comment I encountered was ‘Why would you do that?’ I didn’t realize how uninteresting that history might be to programmers and I’m not quite sure if and how to change that.

**Stuck in a paradigm**

Another byproduct of reading through those older books was that it also made me question the relevance of some of the tools that we’ve inherited. The world that necessitated their creation isn’t the one that we’re programming in now.

A book that I started a while ago based on the recommendation of a fellow RC Start person, was [‘Code’ by Charles Petzold](https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319). One of the major themes of the book is that being locked into a paradigm hinders progress and innovation. It’s hard not to wonder that about Unix, or as Kreminski writes:

_'What are the odds that we somehow stumbled upon the best possible interface for interacting with the computer 40 years ago? What are the odds, in other words, that what we’re doing still makes sense today?’_

None of this means I don’t want to learn about Unix, the command line or operating systems. Unix is still a powerful system, if flawed, and I get a lot of enjoyment, delight even, from gaining mastery over it. I'm not quite as negative about Unix as some of the voices out there, but I realize that my feelings about it are influenced by my newness to programming and also because I'm blinded by what it can do, not how well it does things. All that aside, it also doesn't mean I've stopped thinking about many of the issues that Kreminski describes.

___

*You can read Kreminski’s full post here:*

- ['Unix is not an acceptable Unix'](https://mkremins.github.io/blog/unix-not-acceptable-unix/)
